<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="stylesheet" type="text/css" href="../../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../../stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../../stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>SmartMZ的装逼Block by smartmz</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1><a style="color:#000" href="http://smartmz.github.io/" target="_blank">SmartMZ的装逼Block</a></h1>
          <h2>论程序员的职业修为　　/*老师让你擦黑板; 我擦; 我擦||不擦*/</h2>
        </header>
        <hr>
        <section id="main_content">
          <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"></a>【JAVA】 记一次内存泄漏造成的线上故障</h3>

<p><strong>2014-12-21 私信附件故障</strong></p>
<hr>
<p />
<h4>时间轴</h4>
<br/>
<p>
2014-12-19　　群聊服务上线，IOS版本发版
10:47　　第一条storage报警日志
<br/>
11:10　　私信平台故障白页，长微博发送失败，Storage报警持续上升，TFS第一条写失败报警<br />
11:15　　重启storage服务，私信服务恢复，但无法发送私信附件，长微博恢复<br />
11:20　　proxy报警，线程超出阀值；TFS大量balance_plan fail和cannot find block，must create日志<br />
11:23　　重启NS,服务有所恢复<br />
11:45　　私信附件服务恢复
</p>
<h4>私信附件架构</h4>
<p align="center">
  <img src="../images/1.png" width="400" height="351"> </p>
<h4>分析</h4>
storage内存溢出	"内存溢出日志1行,请及时处理！[@1221_10:47]"

扫storage日志：
<pre><code>[root@tfsweb002 logs]# zgrep -i "outofmemory" debug_cn.log.2014122111.gz
2014-12-21 11:00:08 214 [ERROR] Detected OutOfMemory potentia memory > 90%, stop broadcast presence !!!!!!
2014-12-21 11:00:14 139 [ERROR] Detected OutOfMemory potentia memory > 90%, stop broadcast presence !!!!!!
2014-12-21 11:00:20 779 [ERROR] Detected OutOfMemory potentia memory > 90%, stop broadcast presence !!!!!!
2014-12-21 11:00:27 315 [ERROR] Detected OutOfMemory potentia memory > 90%, stop broadcast presence !!!!!!
*** ***</code></pre>
是私信工程打出来的日志，不是系统报警，查找来源：
<pre><code>[root@wbim002 develop-tools]# ./wtool jargrep "Detected OutOfMemory potentia memory"  ../jarsource/
find 'Detected OutOfMemory potentia memory' in ../jarsource/ 
==> Found "Detected OutOfMemory potentia memory" in ../jarsource/api-commons-3.79.jar</code></pre>
来源是平台依赖的基础包。相关代码为：
<pre><code>double maxMemory = (double) runtime.maxMemory() / (1024 * 1024);
double usedMemory = totalMemory - freeMemory;
double percentFree = ((maxMemory - usedMemory) / maxMemory) * 100.0;
if (percentFree < 10) {
	outOfMemory.set(true);
	log.error("Detected OutOfMemory potentia memory > 90%, stop broadcast presence !!!!!!");
} else if (outOfMemory.get() == true && percentFree > 20) {
	outOfMemory.set(false);
	log.error("Detected memory return to normal, memory < 80%, resume broadcast presence.");
}</code></pre>
当时jvm的可用内存小于10%，触发报警。

在报警机器上可以看到：
<pre><code>[root@tfsweb002 home]# grep "java.lang.Thread.State: RUNNABLE" logs1221_jstack |wc -l
<font color="#FF0000">611</font>
[root@tfsweb002 home]# grep "java.lang.Thread.State" logs1221_jstack |wc -l
759</code></pre>
而正常机器上的情况是：
<pre><code>[root@tfsweb015 ~]# jstack 19474 |grep "java.lang.Thread.State: RUNNABLE"|wc -l 
52
[root@tfsweb015 ~]# jstack 19474 |grep "java.lang.Thread.State"|wc -l 
704</code></pre>
报警机器上jvm的RUNNABLE线程数很高。这里有两种可能：<p>1）请求量大　　2）线程累积</p>
不管是哪种情况，都会<font color="#FF0000">占用大量jvm内存</font>。

<p>查询当时的请求量后发现当时的请求量和平时相比<font color="#3333CC">上升了20%左右</font>，量不是很大，说明两种情况均有可能出现。</p>
<pre><code>[root@tfsweb015 ~]# jstat -gccause 19474
  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 
  0.00  <font style="color:#F00">98.80</font>  54.86  58.65  16.86   7352  407.399  <font style="color:#F00">7370</font> 3784.086 4191.485 GCLocker Initiated GC No GC               
 <font style="color:#F00">97.85</font>   0.00  <font style="color:#F00">97.08</font>  38.87  16.86   7359  407.737  7372 3784.138 4191.875 GCLocker Initiated GC No GC</code></pre>

Survivor和eden的使用率均到95%以上。FULL GC次数很高。所以出现“<code>Detected OutOfMemory potentia memory > 90%</code>”是不奇怪的。
<pre><code>root@tfsweb002 logs1221]# jstack 19474 | grep "java.lang.Thread.State: RUNNABLE"
"Attach Listener" daemon prio=10 tid=0x0000000047eaa800 nid=0x7adc waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Image Fetcher 0" daemon prio=10 tid=0x00002aaad04f0000 nid=0x7189 waiting on condition [0x000000006f1e3000]
   java.lang.Thread.State: RUNNABLE
        at sun.awt.image.JPEGImageDecoder.readImage(Native Method)
******</code></pre>

RUNNABLE - waiting on condition状态的方法主要是
<br />
com.sun.imageio.plugins.jpeg.JPEGImageReader.readImage()，共有68例；<br />
com.sun.imageio.plugins.jpeg.JPEGImageReader.readImageHeader()，共有73例。
<br />
相关堆栈：
<pre><code>"catalina-exec-1315" daemon prio=10 tid=0x00002aaad053d000 nid=0x5138 waiting on condition [0x0000000067768000]
   java.lang.Thread.State: RUNNABLE
        at com.sun.imageio.plugins.jpeg.JPEGImageReader.<font color="#FF0000">readImageHeader</font>(Native Method)
        at com.sun.imageio.plugins.jpeg.JPEGImageReader.readNativeHeader(JPEGImageReader.java:532)
        at com.sun.imageio.plugins.jpeg.JPEGImageReader.checkTablesOnly(JPEGImageReader.java:277)
        at com.sun.imageio.plugins.jpeg.JPEGImageReader.gotoImage(JPEGImageReader.java:409)
        at com.sun.imageio.plugins.jpeg.JPEGImageReader.getImageMetadata(JPEGImageReader.java:931)
        at net.coobird.thumbnailator.util.exif.ExifUtils.getExifOrientation(Unknown Source)
        at net.coobird.thumbnailator.tasks.io.InputStreamImageSource.read(Unknown Source)
        at net.coobird.thumbnailator.tasks.SourceSinkThumbnailTask.read(Unknown Source)
        at net.coobird.thumbnailator.Thumbnailator.createThumbnail(Unknown Source)
        at net.coobird.thumbnailator.Thumbnails$Builder.toOutputStream(Unknown Source)
        at cn.sina.as.util.ImageUtil.<font color="#FF0000">reSizeImage</font>(ImageUtil.java:34)
        at cn.sina.as.service.impl.AttachStorageServiceImpl.getStorageThumbnail(AttachStorageServiceImpl.java:733)
        at cn.sina.as.api.servlet.AttachStorageDownloadThumbnailServlet.process(AttachStorageDownloadThumbnailServlet.java:79)
        at cn.sina.as.api.servlet.AbstractAsServlet.process(AbstractAsServlet.java:48)
        at cn.sina.as.api.servlet.BaseASServlet.doGet(BaseASServlet.java:37)
******</code></pre>
reSizeImage()的相关源码：

<pre><code>public static byte[] reSizeImage(byte[] inImage, int resizeL, int resizeH) {
	if (inImage == null) return null;
	try {
	    ByteArrayInputStream <font color="#FFFF00">in</font> = new ByteArrayInputStream(inImage);
	    ByteArrayOutputStream <font color="#FFFF00">out</font> = new ByteArrayOutputStream();
	    Thumbnails.of(in).size(resizeL, resizeH).toOutputStream(out);
	    return out.toByteArray();
	} catch (Exception e) {
	    ApiLogger.warn("ImageUtil reSizeImage error, ", e);
	    return inImage;
	}
}</code></pre>

申请了in和out，在返回时没有close()，多线程情况下造成内存泄漏。

<pre><code>[root@tfsweb015 ~]# jmap -histo 19474 | head

 num     #instances         #bytes  class name
----------------------------------------------
   1:        250336     <font color="#FF0000">3972708320  [B</font>
   2:        283254       56727104  [C
   3:        192806       32522808  [I
   4:        397600       15904000  java.util.concurrent.ConcurrentHashMap$Segment
   5:        398604       12755328  java.util.concurrent.locks.ReentrantLock$NonfairSync
   6:        397600        9819184  [Ljava.util.concurrent.ConcurrentHashMap$HashEntry;
   7:         64589        9561736  <constMethodKlass></code></pre>

Byte[] 占用的heap最大。而从代码逻辑来看，私信附件的读入读出都使用Byte[].

<pre><code>[root@tfsweb015 ~]# jmap -dump:format=b,file=/data0/heap.bin 19474</code></pre>
<p>使用Eclipse IDE Memory Analyzer分析如图2和图3。 </p>
<p align="center">
  <img src="../images/2.png" width="400"> </p>
从图中可以看到，果然有内存泄漏，看起来是finalize()的内存泄漏。继续在jdk的javax.imageio中查找finalize的踪影，发现com.sun.imageio.stream.StreamFinalizer()会对ImageInputStream执行StreamFinalizer()方法，其中实现了finalize()：
<pre><code>
public class StreamFinalizer {
    private ImageInputStream stream;

    public StreamFinalizer(ImageInputStream stream) {
        this.stream = stream;
    }

    protected void finalize() throws Throwable {
        try {
            stream.close();
        } catch (IOException e) {
        } finally {
            stream = null;
            super.finalize();
        }
    }
}
</code></pre>
对该方法长长的注释说明：<br />
Image{Input,Output}Stream如果被用户类继承；在构造时会构造StreamFinalizer。Image{Input,Output}Stream和StreamFinalizer彼此保留对方的应用，如果双方不可达，就会调用StreamFinalizer.finalize()，以便释放Image{Input,Output}Stream。<br />
在reSizeImage()方法中，我们没有主动close(in，out)，由于finalize()真正的执行优先级比较低，平常负载不重的情况下有机会被调用，Image{Input,Output}Stream和可以被释放，但负载高的时候finalize()被调用的几率会很少，就造成内存泄漏。<br />

<p>&nbsp;</p>
        </section>
        <footer>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>        
      </div>
    </div>
  </body>
</html>